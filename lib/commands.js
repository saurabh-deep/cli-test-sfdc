const timestamp = require('./timestamp');

const forcedLowerCase = str => (typeof str === 'string' ? str.toLowerCase() : str);

const packageBuild = {
  command: 'package:build',
  desc: 'build a deployment package',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx-org'],
  builder: {
    legacy: yargs => yargs.options({
      u: {
        alias: 'org.username',
        describe: 'Salesforce Username',
        group: 'package:build',
      },
      p: {
        alias: 'org.password',
        describe: 'Salesforce Password',
        group: 'package:build',
      },
      s: {
        alias: 'org.serverurl',
        describe: 'Salesforce Server URL',
        group: 'package:build',
      },
      t: {
        alias: 'target',
        describe: 'Will search for first tag that matches <target>-* and create a package based on the diff',
        group: 'package:build',
        demandOption: true,
        coerce: forcedLowerCase,
      },
      r: {
        alias: 'refresh',
        describe: 'Environment that was refreshed from. Will override --target parameter to find metadata that is different than the environment specified',
        group: 'package:build',
      },
      d: {
        alias: 'testDiff',
        group: 'deploy:source',
        type: 'boolean',
        default: false,
        hidden: true,
      },
      noDestructive: {
        describe: 'Do not build package with destructive changes',
        default: false,
        type: 'boolean',
        group: 'package:build',
      },
    }),
    org: yargs => yargs.options({
      p: {
        alias: 'sourcepath',
        describe: 'Comma-separated list of paths to the local source files to include in the package',
        group: 'package:build',
        demandOption: true,
        requiresArg: true,
      },
      a: {
        alias: 'targetalias',
        describe: 'Alias for the target org',
        group: 'package:build',
        demandOption: true,
        requiresArg: true,
      },
      noDestructive: {
        describe: 'Do not build package with destructive changes',
        default: false,
        type: 'boolean',
        group: 'package:build',
      },
    }),
  },
};

const packageClean = {
  command: 'package:clean',
  desc: 'remove a package generated by package:build',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx-org'],
  builder: {},
};

const deployPackage = {
  command: 'deploy:package',
  desc: 'deploy a built package to Salesforce',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: yargs => yargs.options({
    u: {
      alias: 'org.username',
      describe: 'Salesforce Username',
      group: 'deploy:package',
    },
    p: {
      alias: 'org.password',
      describe: 'Salesforce Password',
      group: 'deploy:package',
    },
    s: {
      alias: 'org.serverurl',
      describe: 'Salesforce Server URL',
      group: 'deploy:package',
    },
    t: {
      alias: 'target',
      describe: 'Org target to deploy to',
      group: 'deploy:package',
      coerce: forcedLowerCase,
    },
    l: {
      alias: 'deploy.testLevel',
      describe: 'Specifies which level of deployment tests to run.',
      group: 'deploy:package',
      choices: ['NoTestRun', 'RunSpecifiedTests', 'RunLocalTests', 'RunAllTestsInOrg'],
    },
    e: {
      alias: 'deploy.testSuites',
      describe: 'Comma-separated list of test suites to run',
      group: 'deploy:package',
    },
    k: {
      alias: 'deploy.checkOnly',
      describe: 'Whether to run a validation only deploy',
      default: true,
      type: 'boolean',
      group: 'deploy:package',
    },
    y: {
      alias: 'deploy.enabled',
      describe: 'Whether or not to actually deploy',
      default: false,
      type: 'boolean',
      group: 'deploy:package',
    },
    x: {
      alias: 'timestampFormat',
      default: 'YYYY-MM-DD_HHmmss',
      describe: 'See https://www.npmjs.com/package/time-stamp#customizing-the-timestamp',
    },
    d: {
      alias: 'timestamp',
      group: 'deploy:package',
      default: timestamp.defaultTimestamp(),
    },
    noDestructive: {
      describe: 'Do not deploy with destructive changes',
      default: false,
      type: 'boolean',
      group: 'deploy:package',
    },
  }).check((args) => {
    if (!args.t && (!args.u || !args.p)) {
      const err = 'Must specify either a target (-t,--target) or username (-u,--org.username) and password (-p,--org.password)';
      throw err;
    }
    return true;
  }),
};

const deployMetadata = {
  command: 'deploy:metadata',
  desc: 'deploy specified metadata to salesforce',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: yargs => yargs.options({
    src: {
      describe: 'Glob pattern to deploy, can be repeated',
      group: 'deploy:metadata',
      demandOption: true,
    },
    u: {
      alias: 'org.username',
      describe: 'Salesforce Username',
      group: 'deploy:metadata',
    },
    p: {
      alias: 'org.password',
      describe: 'Salesforce Password',
      group: 'deploy:metadata',
    },
    s: {
      alias: 'org.serverurl',
      describe: 'Salesforce Server URL',
      group: 'deploy:metadata',
    },
    t: {
      alias: 'target',
      describe: 'Org target to deploy to',
      group: 'deploy:metadata',
      coerce: forcedLowerCase,
    },
    l: {
      alias: 'deploy.testLevel',
      describe: 'Specifies which level of deployment tests to run.',
      group: 'deploy:metadata',
      choices: ['NoTestRun', 'RunSpecifiedTests', 'RunLocalTests', 'RunAllTestsInOrg'],
    },
    e: {
      alias: 'deploy.testSuites',
      describe: 'Comma-separated list of test suites to run',
      group: 'deploy:metadata',
    },
    k: {
      alias: 'deploy.checkOnly',
      describe: 'Whether to run a validation only deploy',
      default: true,
      type: 'boolean',
      group: 'deploy:metadata',
    },
  }).check((args) => {
    if (!args.t && (!args.u || !args.p)) {
      const err = 'Must specify either a target (-t,--target) or username (-u,--org.username) and password (-p,--org.password)';
      throw err;
    }
    return true;
  }),
};

const deploySource = {
  command: 'deploy:source',
  desc: 'Deploy a built package to Salesforce',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-org'],
  builder: yargs => yargs.options({
    p: {
      alias: 'sourcepath',
      describe: 'Comma-separated list of paths to the local source files to deploy.',
      group: 'deploy:source',
      demandOption: true,
      requiresArg: true,
    },
    a: {
      alias: 'targetalias',
      describe: 'Alias for the target org.',
      group: 'deploy:source',
      demandOption: true,
      requiresArg: true,
    },
    c: {
      alias: 'checkonly',
      describe: 'Validates the deployed metadata and runs the Apex tests, but prevents the deployment from being saved to the org.',
      default: false,
      type: 'boolean',
      group: 'deploy:source',
    },
    o: {
      alias: 'ignoreerrors',
      describe: 'Ignores the deploy errors, and continues with the deploy operation. The default is false. Keep this parameter set to false when deploying to a production org. If set to true, components without errors are deployed, and components with errors are skipped.',
      default: false,
      type: 'boolean',
      group: 'deploy:source',
    },
    g: {
      alias: 'ignorewarnings',
      describe: 'If a warning occurs and ignorewarnings is set to true, the success field in DeployMessage is true. When ignorewarnings is set to false, success is set to false, and the warning is treated like an error.',
      default: false,
      type: 'boolean',
      group: 'deploy:source',
    },
    l: {
      alias: 'testlevel',
      describe: 'Specifies which level of deployment tests to run.',
      default: 'RunLocalTests',
      group: 'deploy:source',
      choices: ['NoTestRun', 'RunSpecifiedTests', 'RunLocalTests', 'RunAllTestsInOrg'],
    },
    r: {
      alias: 'runtests',
      describe: 'Tests to run if --testlevel RunSpecifiedTests',
      group: 'deploy:source',
      requiresArg: true,
    },
    w: {
      alias: 'wait',
      describe: 'The number of minutes to wait for the command to complete.',
      group: 'deploy:source',
      type: 'number',
      requiresArg: true,
      default: 60,
    },
    d: {
      alias: 'testDiff',
      describe: 'When provided, this option will override --testlevel and --runtests arguments to dynamically execute the tests specified by the Test Configuration.',
      group: 'deploy:source',
      type: 'boolean',
      default: false,
    },
    noDestructive: {
      describe: 'Do not deploy with destructive changes.',
      default: false,
      type: 'boolean',
      group: 'deploy:source',
    },
  }).check((args) => {
    if (args.targetalias.includes('@')) {
      throw new Error('Please provide an alias. Must not contain @ character.');
    }
    if (args.testlevel === 'RunSpecifiedTests' && !args.runtests) {
      throw new Error('Option runtests must not be empty when a testlevel of RunSpecifiedTests is used.');
    }
    return true;
  }),
};

const deployTag = {
  command: 'deploy:tag',
  desc: 'tag a deployment and push to the remote repo',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: yargs => yargs.options({
    t: {
      alias: 'target',
      describe: 'Org target to tag for release',
      group: 'deploy:tag',
      demandOption: true,
      coerce: forcedLowerCase,
    },
    x: {
      alias: 'timestampFormat',
      describe: 'Date/Time format for tag see: https://www.npmjs.com/package/timestamp',
      group: 'deploy:tag',
      default: 'YYYY-MM-DD_HHmmss',
    },
    y: {
      alias: 'deploy.enabled',
      default: false,
      type: 'boolean',
    },
    d: {
      alias: 'timestamp',
      group: 'deploy:tag',
      default: timestamp.defaultTimestamp(),
    },
  }),
};

const retrieveUnpackaged = {
  command: 'retrieve:unpackaged',
  desc: 'retrieve a package from Salesforce based on a package.xml file',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: yargs => yargs.options({
    f: {
      alias: ['manifest', 'package'],
      describe: 'Path to package.xml file',
      demandOption: true,
      group: 'retrieve:unpackaged',
    },
    u: {
      alias: 'org.username',
      describe: 'Salesforce Username',
      group: 'retrieve:unpackaged',
    },
    p: {
      alias: 'org.password',
      describe: 'Salesforce Password',
      group: 'retrieve:unpackaged',
    },
    s: {
      alias: 'org.serverurl',
      describe: 'Salesforce Server URL',
      group: 'retrieve:unpackaged',
    },
    t: {
      alias: 'target',
      describe: 'Org target to retrieve from',
      group: 'retrieve:unpackaged',
      coerce: forcedLowerCase,
    },
  }),
};

const retrievePackage = {
  command: 'retrieve:package',
  desc: 'retrieve a package from Salesforce based on a package name',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: yargs => yargs.options({
    n: {
      alias: 'packages',
      describe: 'comma separated list of package names',
      demandOption: true,
      group: 'retrieve:package',
    },
    u: {
      alias: 'org.username',
      describe: 'Salesforce Username',
      group: 'retrieve:package',
    },
    p: {
      alias: 'org.password',
      describe: 'Salesforce Password',
      group: 'retrieve:package',
    },
    s: {
      alias: 'org.serverurl',
      describe: 'Salesforce Server URL',
      group: 'retrieve:package',
    },
    t: {
      alias: 'target',
      describe: 'Org target to retrieve from',
      group: 'retrieve:package',
      coerce: forcedLowerCase,
    },
  }),
};

const retrieveMetadata = {
  command: 'retrieve:metadata',
  desc: 'retrieve metadata from Salesforce based on command parameters',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: yargs => yargs.options({
    n: {
      alias: 'name',
      describe: '(repeatable) metadata types to retrieve',
      demandOption: true,
      group: 'retrieve:metadata',
    },
    m: {
      alias: 'members',
      describe: '(repeatable) comma separated list of metadata type members to retrieve for each type (must follow -n parameter)',
      group: 'retrieve:metadata',
    },
    u: {
      alias: 'org.username',
      describe: 'Salesforce Username',
      group: 'retrieve:metadata',
    },
    p: {
      alias: 'org.password',
      describe: 'Salesforce Password',
      group: 'retrieve:metadata',
    },
    s: {
      alias: 'org.serverurl',
      describe: 'Salesforce Server URL',
      group: 'retrieve:metadata',
    },
    t: {
      alias: 'target',
      describe: 'Org target to retrieve from',
      group: 'retrieve:metadata',
      coerce: forcedLowerCase,
    },
  })
    .example('adx retrieve:metadata', '-n ApexClass -n ApexPage -t VCQA')
    .example('adx retrieve:metadata', '-n ApexClass -m ClassA,ClassB -n ApexPage -m PageA,PageB -t VCQA'),
};

const sort = {
  command: 'sort',
  desc: 'alias for sort:diff',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx-org'],
  builder: yargs => yargs.options({
    t: {
      alias: 'target',
      describe: 'Org target to diff from. Will search for latest tag matching <target>-*. If not provided will diff from HEAD',
      group: 'sort',
      coerce: forcedLowerCase,
    },
  }),
};

const sortDiff = {
  command: 'sort:diff',
  desc: 'sort metadata that has changed since the last deployment',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx-org'],
  builder: yargs => yargs.options({
    t: {
      alias: 'target',
      describe: 'Org target to diff from. Will search for latest tag matching <target>-*. If not provided will diff from HEAD',
      group: 'sort:diff',
      coerce: forcedLowerCase,
    },
  }),
};

const sortAll = {
  command: 'sort:all',
  desc: 'sort all sortable metadata',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx-org', 'sfdx-package', 'sfdx'],
  builder: {},
};

const sortCheck = {
  command: 'sort:check',
  desc: 'verify that metadata is sorted (used by CI)',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx-org'],
  builder: yargs => yargs.options({
    t: {
      alias: 'target',
      describe: 'Org target to diff from. Will search for latest tag matching <target>-*. If not provided will diff from HEAD',
      group: 'sort:check',
      coerce: forcedLowerCase,
    },
  }),
};

const sortWatch = {
  command: 'sort:watch',
  desc: 'will run in background and automatically sort metadata as it changes',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx-org', 'sfdx-package', 'sfdx'],
  builder: {},
};

const resourcesBuild = {
  command: 'resources:build',
  desc: 'build static resource packages based on resources config',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: yargs => yargs.options({
    r: {
      alias: 'resource',
      describe: 'Name of folder under resources/ containing a config.json file to build',
      group: 'resources:build',
    },
    t: {
      alias: 'target',
      describe: 'Org target to diff from so we only build modified resources',
      group: 'resources:build',
      coerce: forcedLowerCase,
    },
  }),
};

const resourcesCheck = {
  command: 'resources:check',
  desc: 'check that built static resources match resources contents',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: {},
};

const sfdxCiDeploy = {
  command: 'ci:deploy',
  desc: false,
  commandType: 'project',
  projectType: 'sfdx',
  builder: yargs => yargs.options({
    d: {
      alias: 'destination',
      describe: 'Destination Org',
      group: 'ci:deploy',
      demandOption: true,
      requiresArg: true,
    },
    checkonly: {
      describe: 'Validates the deployed metadata and runs all Apex tests, instead of actually deploying.',
      group: 'ci:deploy',
      type: 'boolean',
    },
  }),
};

const sfdxAuth = {
  command: 'sfdx:auth',
  desc: false, // 'Finds dev hub or authorize; If no default dev hub is found performs authorization.'
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-org', 'sfdx-package'],
  builder: yargs => yargs.options({
    a: {
      alias: 'setalias',
      describe: 'Set an alias for the authenticated org',
      group: 'sfdx:auth',
    },
  }),
};

const sfdxInit = {
  command: 'sfdx:init',
  desc: 'Sets up new scratch org/sandbox, pushes source, assigns permission set, imports data and opens new org.',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-org', 'sfdx-package'],
  builder: yargs => yargs.options({
    t: {
      alias: 'type',
      describe: 'The type of org to create. For Org Development Model, defaults to sandbox. For Package Development Model, defaults to scratch.',
      group: 'sfdx:init',
      choices: ['scratch', 'sandbox'],
    },
    a: {
      alias: 'setalias',
      describe: 'Set an alias for for the created scratch org/sandbox.',
      group: 'sfdx:init',
      requiresArg: true,
    },
    f: {
      alias: 'definitionfile',
      describe: 'Path to a scratch org/sandbox definition file. For scratch org, defaults to config/project-scratch-def.json. For sandbox, defaults to config/project-sandbox-def.json.',
      group: 'sfdx:init',
      requiresArg: true,
    },
    w: {
      alias: 'wait',
      describe: 'Time to wait for successful creation of scratch org/sandbox, in minutes.',
      group: 'sfdx:init',
      type: 'number',
      requiresArg: true,
      default: 60,
    },
    d: {
      alias: 'durationdays',
      describe: 'Duration of the scratch org, in days (min:1, max: 30).',
      group: 'sfdx:init options applicable for scratch org',
      type: 'number',
      requiresArg: true,
      default: 7,
    },
    u: {
      alias: 'targetusername',
      describe: 'SFDX username or alias for the production org with sandbox licenses. Overrides productionOrgId defined in config/appirio.json.',
      group: 'sfdx:init options applicable for sandbox',
      requiresArg: true,
    },
    r: {
      alias: 'domainresolutionwait',
      describe: 'Time to wait for new sandbox domain resolution after sandbox has been created, in minutes.',
      group: 'sfdx:init options applicable for sandbox',
      type: 'number',
      requiresArg: true,
      default: 5,
    },
  }),
};

const sfdxWatch = {
  command: 'sfdx:watch',
  desc: 'Watches files in your workspace and the scratch org/sandbox for changes and pushes/pulls changes automatically.',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-org', 'sfdx-package'],
  builder: {},
};

const sfdxAssign = {
  command: 'sfdx:assign',
  desc: 'Assigns named permission sets to the default username.',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-org', 'sfdx-package'],
  builder: yargs => yargs.options({
    n: {
      alias: 'permissionsets',
      describe: 'Comma separated names of the permission sets to assign.',
      type: 'string',
      group: 'sfdx:assign',
      demandOption: true,
      requiresArg: true,
    },
  }),
};

const sfdxP2Sync = {
  command: 'sfdx:package:sync',
  desc: 'Synchronizes Salesforce DX Packaging 2 packages between a sfdx-project.json and local Appirio DX configuration files',
  commandType: 'project',
  projectType: 'sfdx',
  builder: {},
};

const sfdxP2Create = {
  command: 'sfdx:package:create',
  desc: 'Create one or more second generation packages based on the local configuration files',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-package'],
  builder: {},
};

const sfdxP2Update = {
  command: 'sfdx:package:update',
  desc: 'Update package name and description on the DevHub to match the local configuration files',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-package'],
  builder: {},
};

const sfdxPackagePublish = {
  command: 'sfdx:package:publish',
  desc: 'Create new versions of all packages defined in the local configuration files',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-package'],
  builder: yargs => yargs.options({
    k: {
      alias: 'installationkey',
      describe: 'installation key for key-protected package (either --installationkey or --installationkeybypass is required)',
      group: 'sfdx:package:publish',
      requiresArg: true,
    },
    x: {
      alias: 'installationkeybypass',
      describe: 'bypass the installation key requirement (either --installationkey or --installationkeybypass is required)',
      group: 'sfdx:package:publish',
    },
  }).check((args) => {
    if (!args.k && !args.x) {
      const err = 'ERROR:  A required parameter is missing. Include either an --installationkey (-k) value or --installationkeybypass (-x).';
      throw err;
    }
    return true;
  }),
};

const sfdxP2Publish = {
  command: 'sfdx:p2:publish',
  desc: false,
  commandType: 'project',
  projectType: 'sfdx',
  builder: {},
};

const sfdxPackageInstall = {
  command: 'sfdx:package:install',
  desc: 'Install all packages present in the local configuration files on a target org',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-package'],
  builder: yargs => yargs.options({
    d: {
      alias: 'destination',
      describe: 'Provide the target org name, on which you want to install the package.',
      group: 'sfdx:package:install',
      demandOption: true,
      requiresArg: true,
    },
    k: {
      alias: 'installationkey',
      describe: 'installation key for key-protected package (either --installationkey or --installationkeybypass is required)',
      group: 'sfdx:package:install',
      requiresArg: true,
    },
    x: {
      alias: 'installationkeybypass',
      describe: 'bypass the installation key requirement (either --installationkey or --installationkeybypass is required)',
      group: 'sfdx:package:install',
    },
    r: {
      alias: 'release',
      describe: 'promote your beta package versions to released before you install them.',
      group: 'sfdx:package:install',
    },
  }).check((args) => {
    if (!args.k && !args.x) {
      const err = 'ERROR:  A required parameter is missing. Include either an --installationkey (-k) value or --installationkeybypass (-x).';
      throw err;
    }
    return true;
  }),
};

const sfdxP2Install = {
  command: 'sfdx:p2:install',
  desc: false,
  commandType: 'project',
  projectType: 'sfdx',
  builder: yargs => yargs.options({
    d: {
      alias: 'destination',
      describe: 'Provide the target org name, on which you want to install the package.',
      group: 'sfdx:package:install',
      demandOption: true,
      requiresArg: true,
    },
  }),
};

const salesforceDemo = {
  command: 'salesforce:demo',
  desc: false,
  commandType: 'all',
  builder: yargs => yargs.options({
    o: {
      alias: 'orgs',
      describe: 'The aliases of orgs to be created',
      group: 'salesforce:demo',
      demandOption: true,
      requiresArg: true,
    },
    json: {
      describe: 'Get JSON output for this command',
      group: 'salesforce:demo',
      type: 'boolean',
    },
  }),
};

const metadataList = {
  command: 'metadata:list',
  desc: 'Generates the manifest file (package.xml) from the source org metadata',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx', 'sfdx-org', 'sfdx-package'],
  builder: yargs => yargs.options({
    u: {
      alias: 'targetusername',
      describe: 'SFDX username or alias for the source org.',
      group: 'metadata:list',
      demandOption: true,
      requiresArg: true,
    },
    f: {
      alias: 'file',
      describe: 'Path to the output manifest file',
      group: 'metadata:list',
      demandOption: true,
      requiresArg: true,
    },
    o: {
      alias: 'output',
      describe: 'Output Type. Only XML output is supported at present.',
      default: 'XML',
      group: 'metadata:list',
      requiresArg: true,
      coerce: forcedLowerCase,
    },
  }),
};

const metadataUnique = {
  command: 'metadata:unique',
  desc: 'Checks for conflicting metadata among two or more packages',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx', 'sfdx-org', 'sfdx-package'],
  builder: yargs => yargs.options({
    p: {
      alias: 'sourcepath',
      describe: 'Comma separated list of paths of all the packages that are to be checked for metadata overlapping',
      group: 'metadata:unique',
      demandOption: true,
      requiresArg: true,
    },
  }),
};

const cmcPackage = {
  command: 'cmc:package',
  desc: 'Retrieve package.xml and destructiveChanges.xml (for any destructive changes) from CMC based on list of stories/issues or a sprint',
  commandType: 'project',
  projectType: ['legacy-salesforce', 'sfdx', 'sfdx-org', 'sfdx-package'],
  builder: yargs => yargs.options({
    n: {
      alias: 'itemnumbers',
      describe: 'Comma separated list of CMC story and/or issue numbers for which manifest items need to be retrieved',
      group: 'cmc:package',
      requiresArg: true,
    },
    s: {
      alias: 'sprint',
      describe: 'A single CMC Sprint Name for which manifest items need to be retrieved',
      group: 'cmc:package',
      requiresArg: true,
    },
    d: {
      alias: 'destination',
      describe: 'Destination path where the files(package.xml and destructiveChanges.xml) will be written',
      group: 'cmc:package',
      requiresArg: true,
    },
  }).check((args) => {
    if (args.n && args.s) {
      const err = 'Either comma-separated list of stories/issues (-n, --itemnumbers) or a single Sprint (-s, --sprint) allowed!';
      throw err;
    }
    if (!args.n && !args.s) {
      const err = 'Either specify a comma-separated list of stories/issues (-n, --itemnumbers) or a single Sprint (-s, --sprint)!';
      throw err;
    }
    return true;
  }),
};

const cmcManifest = {
  command: 'cmc:manifest',
  desc: 'Creates manifest items in CMC for the stories/issues mentioned in the supplied message',
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: yargs => yargs.options({
    m: {
      alias: 'message',
      describe: 'Message text to use CMC story/issue number(s) from',
      group: 'cmc:manifest',
      demandOption: true,
      requiresArg: true,
    },
  }),
};

const ciSetup = {
  command: 'ci:setup',
  desc: 'Set up the CI/CD system',
  commandType: 'project',
  projectType: ['sfdx', 'sfdx-org', 'sfdx-package'],
  builder: yargs => yargs.options({
    f: {
      alias: 'force',
      describe: 'Whether to overwrite existing CI/CD configuration',
      group: 'ci:setup',
      type: 'boolean',
      default: false,
    },
  }),
};

// Deprecated commands - Start
const packageDeploy = {
  command: 'package:deploy',
  desc: false,
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: {},
};

const packageDeployMetadata = {
  command: 'package:deploy:metadata',
  desc: false,
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: {},
};

const packageTag = {
  command: 'package:tag',
  desc: false,
  commandType: 'project',
  projectType: 'legacy-salesforce',
  builder: {},
};

const sandboxAssign = {
  command: 'sandbox:assign',
  desc: 'Creates/updates the current Git branch and sandbox mapping and sets defaultusername for the project.',
  commandType: 'project',
  projectType: 'sfdx-org',
  builder: yargs => yargs.options({
    u: {
      alias: 'targetusername',
      describe: 'SFDX username or alias for the sandbox org that you want to map with the current branch.',
      group: 'sandbox:assign',
      requiresArg: true,
      demandOption: true,
    },
  }),
};
// Deprecated commands - Finish

module.exports = [
  packageBuild, packageClean,
  deployPackage, deployMetadata, deployTag, deploySource,
  retrieveUnpackaged, retrievePackage, retrieveMetadata,
  sort, sortDiff, sortAll, sortCheck, sortWatch,
  resourcesBuild, resourcesCheck,
  sfdxAuth,

  sfdxCiDeploy, sfdxInit, sfdxWatch, sfdxAssign,
  sfdxP2Sync, sfdxP2Create, sfdxP2Update, sfdxPackagePublish, sfdxP2Publish, sfdxPackageInstall, sfdxP2Install,
  packageDeploy, packageDeployMetadata, packageTag,
  salesforceDemo, metadataList, metadataUnique,
  cmcPackage, cmcManifest, ciSetup, sandboxAssign,
];
